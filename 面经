1. dll加载方式
动态链接库
  动态 静态
  链接时期不同：编译期和运行期
  静态链接：编译期就将dll链接到文件，体积大。
  动态链接：在运行期，才进行链接。
2. 线程池 内存池
  并发   内存碎片
3. epoll, poll, select
  IO多路复用，通过一个描述符，来监控多个io调用，当有io调用事件出触发，就可以让线程来处理。 优点在于节省线程。
  select有监视描述符数量限制，select和poll都是在事件触发时无法返回具体确认的io描述符，但是epoll会，无需轮训。
  内核和内存copy交互，epoll只有一次，将就绪的描述符维护在内核的就绪队列上。
  
5. stl

6. tcp udp 

8. lt et
    LT:当描述符就绪时，线程可以先不处理，但是下次调用epoll——wait时再通知，适合阻塞和非阻塞。 触发次数多。
    ET：必须马上处理，否则下次不通知，适用非阻塞。
    
    就绪列表中删不删除触发的io事件。
9. c c++  struct 区别
   c:不能有函数，变量体的集合。
   
10. tcp 序列号，确认号
  传输中：保证时序性，每次传输接收方成功都会发送确认数据包，确认号就是接收的序列号加上数据包长度。，如果三次错误就会重传。
  连接时：三次握手 保证链接成功。完成序号的初始化。
  
11. get post
  get 是请求资源，尔post是传输实体。
  get的参数都在url中，而post参数在实体中。而且get有长度限制。1024kb， get也只能传ASCII字符。
  get只是读取资源，回退无法对服务器造成改动，而post可以通过实体改变服务器。
  get 可缓存，post不可。
  
  get通常是用来请求资源，而post用来提交表单。但post也可以获取资源。
  get相比来说安全性低，参数包在url之中，post参数藏在body实体之中。
  get可以被浏览器缓存，而post一般不缓存。
  get请求发送产生一个tcp数据包，将header和body一起发送出去。 post一般分成两部，第一次只发送header，服务器响应100后再发送body。
  
  post一般分成两个数据包，一次发header，第二次发data。 get会发header+data。
14. 微服务
    单体应用：功能开发打包一起。就像传统客户端与服务器交互，可以负载均衡支持多服务器，cdn加载静态资源。但只是部署进行了优化。
    代码臃肿，容错性差，开发协作困难。
    
    微服务：面向服务的架构思想。
    1.单一职责的，一个微服务应该都是单一职责的。
    2. 面向服务的。将自己的业务能力封装并对外提供服务。
    
    服务发现：服务注册中心
    服务配置管理的问题：配置中心
    


17. redis
  单线程内存型键值数据库，string,set,list,hash,zset. 支持持久化。 
  与memcache：1持久化，2内存大小 3支持类型
  内部结构：dic， 跳跃表（多指针链表，能二分查找）
  过期删除，内存淘汰。
  
18. vector, hashmap,lru,shared_ptr,快排，堆排, 快速中位数

int partition(vector<int>& s,int l,int r){
  int p=s[r],i=l,j=r;
  while(i<j){
    while(s[i]<p) ++i;
    s[j]=s[i];
    while(s[j]>p) --j;
    s[i]=s[j];
  }
  s[i]=p;
return i;
}

void quicksort(vector<int>& s,int l,int r){
  if(l>=r) return ;
  int p=partition(s,l,r);
  quicksort(s,l,p-1);
  quicksort(s,p+1,r);
}

void maxheap(vector<int>& s, int i, int size){
  int l=i*2+1,r=i*2+2,large=i;
  if(s[l]>s[large]) large=l;
  if(s[r]>s[large]) large=r;
  if(large!=i) maxheap(s,large,size)
}

void buildheap(vector<int>& s,int size){
  for (int i=size/2;i>=0;--i{
    maxheap(s,i,size);
  }

}

19.strcpy,strncpy, memcpy,memmove

  strncpy: 超出count的部分用‘\0’补。
  memmove：对于dst在src后面且有重叠时，要从后往前复制。

20. 高并发tcp
  第一，tcp连接数量不局限于端口数，而是linux系统最大可打开文件数。ulimit-n 可以查看最大文件数。
                第一步，修改/etc/security/limits.conf文件，在文件中添加如下行：
                speng soft nofile 10240
                speng hard nofile 10240
                第二步，修改/etc/pam.d/login文件，在文件中添加如下行：
                session required /lib/security/pam_limits.so
                第三步，查看Linux系统级的最大打开文件数限制，使用如下命令：
                [speng@as4 ~]$ cat /proc/sys/fs/file-max
                12158
  第二，使用支持高并发网络I/O的编程技术，非阻塞io，io多路复用。
  
  12. 多线程

  13. 设计模式
  
  单例模式：
    确保一个类只有一个实例，并提供该实例的全局访问点。 构造函数private
    饿汉模式
    懒汉模式：性能高，但有线程安全问题。 二检锁，静态类对象。
    
  观察者模式：
    定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。
    主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。
    观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。
  
  简单工厂：
    将实例化操作单独放一个类中，工厂类。将产品类型作为参数，工厂类来操作具体实例化哪个产品实例。
  工厂方法：
    将工厂类也抽象化，不同的产品通过不同的工厂来创建实例。
  抽象工厂模式：
    工厂方法就已经完成了对工厂类的抽象，但是工厂方法只适用于产品种类单一的情况，一个工厂为一类产品提供借口；但是抽象工厂可以通过一个工厂生产多个产品，有多个产品实例化的接口。
    
  生产者-消费者模式：
    经典的多线程并发协作模式。将生产和消费解藕，通过两种线程以共享内存（内核缓冲区）的方式进行数据交流。
    通常需要条件变量和mutex来保证线程的同步机制。
    
    
    
    
    
 14. 常用协议，端口号。
      http:   80   tcp
      https:  443  tcp
      dns:    53   udp
      ftp:    21(控制连接） 20 （数据连接） tcp
      telnet：23    tcp
      
 15. 如何让udp可靠
 
    三种可靠等级：尽力可靠，无序可靠，有序可靠。
    tcp缺点：速度慢，网络环境要求高，延迟问题；3次握手，4次挥手 占用资源； 重传占用带宽
    
    核心：
        重传模式：超时重传，请求重传，FEC选择重传。
                
                1 超时重传：依赖于ack回复，等待rto时间。  
                2 请求重传：接收端发送是ack时附带上丢失的报文信息。 序号
                3. FEC选择重传：前向纠错技术，在发送端将报文进行FEC分组，在接收端丢包能根据FEC分组算法还原。
                
      rto=srtt+srtt_var
      
        窗口与拥塞控制：避免带宽占用过高
        
 16. 大量time_wait 怎么解决  （端口占用）
 
 服务器关闭连接后，客户端还会在发送确认后等待time_wait时间，造成大量time_wait占用端口，socket。后面的客户端可能连接不上。（端口号占用）65535
 尤其在高并发短连接问题大。 
 
      1 Time_wait 客户端   连接复用       sysctl.conf      tcp_tw_reuse=1
      客户端再次向同一个服务器发起连接时，复用之前 tw的连接。    （短连接不断重连）
      
      2. Time_wait连接回收   tcp_tw_recycle=1
      内核快速回收socket，（rto） 将socket销毁。  加快timewait  容易造成数据混乱。
      
      
      3. tcp_timestamps=1  
      保存两个时间，1个是发送数据包的时间，1个是最近接收数据包的时间。 reuse 和recycle依赖于timestemp
      
      
      
 17 socket:
   五元组：源ip，源端口，目的ip，目的端口，类型。
    
    
    
  18. static 在类外初始化；
      const 在构造函数中初始化
      static const 可以直接类内初始化
    
19. 拷贝构造函数：&   左值引用
    移动构造函数：&&  右值引用  通常和move搭配


21。 RTTI 运行时类型识别： typeid， dynamic_cast
                      带虚函数在运行期识别，不带在编译期识别。
  
  
  22. decltype   auto
  
  
  23. c++ 11 新特性 ： 智能指针，移动语意，stl容器，auto关键字，lambda表达式
  
  24. linux实现系统调用：
      软中断。  产生一个异常，导致cpu会切换到内核态去处理异常，而异常处理函数就是系统调用函数。
  
  25. shared_ptr 线程安全问题
  
      当多线程读写shared_ptr 指向的同一个对象时，可能会发生竞态。 需要加互斥锁来保护。
      
      std::mutex m;
      unique_lock<mutex> lock(m);
  
  
  26. c++源文件到可执行文件
      预处理阶段：预处理器指令实现文本的替换
      编译阶段：将c++语言翻译汇编语言，汇编文件
      汇编阶段：成机器语言，目标文件
      链接阶段：引用别处的函数，数据。例如标准库和私有库。将目标文件代码和引用的代码连接起来。 可执行文件
      
      
  27. 负载均衡工具：
      LVS：四层负载均衡linux virtual server
      Nginx：七层负载均衡 网页服务器， 
      HAProxy：七层负载均衡


28. 数据库索引
    mysql： B+树
          聚簇索引：在B+树叶子结点中存储全部行数据（有序）， 按照主键建索引。
          二级索引：如果先给其他字段加索引，要 create index。。。on table（字段）；
                  此时数据库建立一个新B+树， 叶子结点只存字段对应主键。
                  查找的时候对照两个表找数据。 回表
          复合索引：create index 。。。 on table （字段1，字段2）；
                    此时数据库又建立一个新B+树，叶子结点存复合字段对应主键。
          
    索引最左匹配原则：
          联合索引中，只能用于查找key组合是否存在，遇到范围查询，后面的索引无法命中。从左到右命中索引。
          
          
          尽量找区分度高的做索引
          
 29. stl中 map，set采用红黑树结构存储数据，相比二叉搜索树，红黑树能保证平衡，查找复杂度平均O（logn）。
      跟节点，叶子结点都是黑色。红色节点子节点必须是黑色的。 通过旋转来做到平衡限制。  最长距离不超过最短的二倍。 路径黑色节点数量相等。
      
      

30. http无状态协议：浏览器对事务处理没有记忆能力，不会记住用户的操作。
    记忆话用户状态信息用到cookie。
    
31. http header： 通用标头，实体标头，请求标头（请求方法，host，版本号），响应标头（状态码，版本号）。
    
32. tcpdump 网络抓包，分析工具。 将数据包头部截取。


33. tcp 三次握手异常 分析
     第一次握手SYN丢包：  隔时间收不到SYN ACK，超时重传，重传次数linux内核指定，等待时间2的指数幂增长。 tcp_syn_retries
     第二次SYN ACK丢包：此时客户端等待SYNACK，而服务器在等待ACK。理论上都会造成超时重传。 但是服务器超时重传只会触发一次，就会再收到SYN包，造成重置。tcp_synack_retries
                      最后也会因为SYN的超时重传终止。
     第三次ACK丢包： 此时服务器等不到ACK 超时重传SYNACK, tcp_synack_retries  。 但客户端处于established状态。 传输数据也会造成重传。tcp_retries。
                  客户端断开established状态：tcp保活机制。tcp_keetalive_time。
              
34. 发送窗口和 MSS：
    窗口：一次发送最多字节数。
    MSS：一个数据包最多字节数。分包           窗口/MSS 一次最多数据包数量
 
35. tcp数据包累计确认机制：
     当收到多个数据包时，不需要为所有包确认，只需要确认最后一个包。
     
     
36. tcp避免小数据报文传输：
    tcp包含20字节头部，数据字节少会造成效率低。
    nagle算法：有发送未确认字节，会囤积起来直到MSS。
    
37. tcp fast open 避免三次握手
    首次连接需要三次握手，但fast open会以cookie形式存在客户端。
    以后的连接，客户端可以直接传数据，附带cookie。
    
38. time_wait作用：1.保证连接正确关闭，防止ack没有到达服务器（被动方）。
                  2. 确保连接中没有旧数据包残存，不会关闭后留在网络中。
                  时间为2MSL
                  
39. pcb 进程控制块
    1 进程描述信息（pid）， 2 进程管理信息（状态，优先级）， 3 资源分配清单，  4 cpu状态信息，上下文（cpu寄存器-程序计数器）
    
    pcb存在系统内核之中。是进程的唯一标示。

40. 进程创建：
    1 分配进程标识号pid， 2. 申请空pcb 3. 分配资源   4. 初始化pcb 
    
41。 pcb组织方式：
    通常通过链表，  就绪队列， 阻塞队列。。。
    
42. cpu上下文切换：（寄存器）
    将当前进程上下文存起来（内核，pcb），找到下一个进程并加载其上下文，跳转到程序计数器所指位置。
    
43. 进程上下文切换：（内核态）
    除了 堆栈，代码段，data，bss 等用户态内存资源。  还要切换内核堆栈，寄存器等资源。
    
    首先要通过分页机制找到下一个进程用户态资源的内存位置，可能造成缺页中断。
    然后还要从下一个进程pcb中提取cpu上下文，进行cpu上下文切换。
    
44.线程内容：
    独立的栈空间和线程控制块（寄存器）。   可以共享进程的资源。
    
    线程缺点：一个线程挂掉可能影响进程中其他线程。
    
45. 进程 线程区别

    。进称是资源分配的单位，线程是独立调度的单位。 线程需共享使用进程的用户态内存资源。
    。进程创建，切换，销毁的开销更大。 进程创建需要通过虚拟内存机制独立分配一块内存资源。进程切换需要考虑切换虚拟内存页，可能造成缺页中断。
      同一进程下的线程切换只会切换栈和寄存器等私有资源。
    。线程通信通常只在用户态进行内存的共享，不需要内核参与。 而进程通信需要陷入内核。
    
46. 线程实现
    用户线程1，内核线程，轻量级线程。
    用户线程：线程控制块在用户态中，不对内核可见。只由用户级线程库函数来处理。
            无需系统调用，速度快。   线程可以通过函数共享进程的cpu时间片，执行会慢。 切换不受内核影响，设计困难。
            
    内核线程：线程控制块在内核中， 通过cpu时间片轮转来获取执行时间。
            当一个线程系统调用而阻塞时，不影响其他线程。
            
    轻量级线程：内核支持的用户级线程。   与内核线程一对一。
    
    
47. 最大tcp连接数：
    理论上是客户端ip数*客户端端口数    2^32 * 2^16
    但通常受限于机能，最大打开文件数。 因为tcp连接也是一个socket文件。
    
48. tcp三次握手：
    避免服务器打开多余的历史连接，造成初始化混乱。
    完成序列号初始化并确认。
    
49. 分片工作在网络层，  mss有什么用

    在网络层：效率更高，不需要考虑上层协议。
    
    mtu：链路层最大传输单元 一般1500
    mss：传输层tcp最大报文段大小 一般1460=1500-20-20； 
    
    当一个ip分片丢失，整个ip报文都要重传。 但网络层IP没有重传机制，需要传输层tcp负责重传。所以ip层分片也很没效率。
    所以为了更高效率，避免ip分片，就可以在tcp连接时协商mss值，在传输层就分好片，到ip层就不用分层了。
    
    
50. tcp 洪泛攻击（dos）
    攻击者通过不同ip地址对服务器频繁进行syn连接，但是不返回第三次握手ack。
    这样服务器端在listen socket监听到连接，将他放入等待连接完成的队列。大量无效syn进入会占据队列空间，导致服务器无法处理新连接。
    
    
    syn cookie防治： 当syn队列满了后，收到syn包不进入队列 而是计算cookie值，将cookie值以syn ack 方式传递回客户端，
                    若收到ack直接进入accept队列。
                    
              
51。 建立连接后，客户端故障？
    tcp保活机制。 每隔时间发送探测报文，若没有响应，则认为死亡。
    
52. ipv4 地址： 
       1 ip分类：
          32位   网络号+主机号
          主机号全0:指定网络
          主机全号1: 网络中所有主机
          
          第一位0:A类地址   
          第二位0: B类地址
          第三位0: C类地址
          
        2 无分类地址：
            最后/x:  前x位为网络号。
            
        3 子网掩码：（掩盖掉主机号区域）
            ip地址32 + 子网掩码32
            两者按位and结果就是网络号。
            
53. 分离网络号和主机号：
    网络号代表同一广播域（同一链路），路由器寻址先按网络号发到网络上。
    

54. 子网划分：
    将主机地址划分为子网主机地址和子网网络地址。
    子网掩码的主机号区1表示子网网络地址  0表示子网主机地址
    
 55. 公有ip 私有ip：
      公有ip由组织分配，在互联网保持唯一。
      
      
 56. ipv6 地址128位     与ipv4不兼容
        ipv6取消 分片，  取消首部检验   ，首部40字节。
        
 57. dns解析：
    1.客户端发出dns请求，先查自身本地dns缓存。
    2. 再查本地dns服务器；
    3. 本地dns服务器再查根域名服务器，根域名服务器告诉顶级域名服务器地址
    
    4.本地dns服务器再查顶级域名服务器，告诉权威dns服务器地址
    5. 权威dns服务器会告诉ip
    6. 本地dns服务器最后将ip返回
    
    
 58. 传输ip数据包 到链路层中需要下一跳mac地址    ARP
    
    主机存ARP高速缓存。  没命中就会广播ARP请求，满足ip就返回mac地址。
    
    
 59. NAT： 网络地址转换
      ipv4地址紧缺，同一个公司，学校，机构可以用私有ip地址，与外部通信时通过NAT表转换为公有ip。
      
      不同 IP 相同 端口号 -> 相同ip  不同端口号
    
 60. icmp：
      网络层中 辅助ip的一个协议，确保ip数据包交付成功，报告失败的原因。
      
      询问报文：ping
      差错报文：traceroute

 61. 进程通信：
    1. 管道：半双工通信，先进先出，只能在血缘进程间通信。 管道就是内核中的一块缓存
            int pipe(int fd[2]);    fd[0]:读取端描述符   fd[1]：写入端描述符
            可以发现 进程描述符存于一个进程中。   因此只能在父子进程之间才能通过管道通信。 使用fork来复制描述符
            管道 半双工  只能一端输入，另一段输出。
            
    2. 命名管道： 取消对关系的限制。
                pipe是通过描述符创建的描述符来作为输出和写入的端口。
                而mkfifo创建了类型为管道的文件。  进程通过该管道通信。
                
    3. 消息队列：加入中间件，解耦读写。
              管道效率低，不适合频繁通信。必须一端写，另一端读。管道不能独立于读写存在 半双工。生命跟随进程
              
              消息队列是内核中的消息链表，先进先出。 可以独立于读写，写操作直接写入队列，读操作直接从队列里拿。生命跟随内核。
              不适合大数据的传输 有长度限制，通信实时性也不高。
              
    4. 共享内存：速度快
              进程各自拿出一块虚拟内存，共同映射到相同的物理内存上。
              
    5. 信号量：
            共享内存会造成数据竞争，信号量可以帮助构建同步机制。 让进程按顺序进入临界区。
            p操作：共享资源之前，信号量-1，小于0会阻塞等待。
            v：共享资源之后，信号量+1，小于等于0会唤醒阻塞进程，大于0说明没有阻塞。
            
       互斥锁： 只有两个互斥值的信号量，能构成互斥      
            
    6. 信号：
            工作异常需要信号通知进程。  唯一的异步通信机制。
            
            sigint：终止进程   sigtstp：停止进程，不结束。 sigkill 立即结束进程
            
    7. socket：
              可以在不同主机间通信
    
    
62. https:
          http+ ssl(secure socket layer)    ssl独立于应用层
          防治明文监听，伪装，篡改。
          
          非对称密钥
          证书 签名机制                CA数字证书：附带公钥；  服务器自带私钥；   服务器响应请求再将数字证书发给客户端。客户端签名验证后将随机key发给服务器
                                                                          服务器再用随机key加密返回客户端。

63. I/O ：
      物理io：从实际存储设备中获取数据 
      逻辑io：从逻辑存储器中获取数据（块，缓冲区）
      
      
      
64. 双层缓冲区：
              应用进程缓冲区：  避免阻塞（读的时候没有数据，写得时候满了）； 读的时候容避免不完整或者读多。
              
              内核缓冲区：缓冲区会占据内存。直接打到进程缓冲区会占据大量内存无法换页。 所以引入内核缓冲区，内核缓冲区满了再换入进程缓冲区
              
    双缓冲：在内核构建两个缓冲区，避免一个缓冲区满了，无法接受新的写入。
    循环缓冲：一个缓冲区，俩指针，一个指向空闲字，一个指向第一个未删除的字，两者到达顶点时，返回底部。
    
65. io：
        应用进程， 内核， 数据
        
        一阶段：内核准备数据，打入内核缓冲区中。
        二阶段：将内核缓冲区数据打入进程缓冲区中。
        
        阻塞/非阻塞：区分在一阶段，调用者等待方式不同，阻塞：休眠，直到通知准备好。不占用cpu资源。
                                               非阻塞：轮训，占用cpu资源。
                                               
        同步/异步：区分在二阶段：调用完成的方式不同。 同步：数据准备好后，由调用者进行数据拷贝工作。
                                               异步：数据准备好后，直接由内核拷贝到用户态，并用回调函数告诉调用者请求完成。
         

66. 多线程：
          线程写共享内存（互斥区）：1.寄存器从内存中读取数据
                       2. 寄存器更新数据
                       3. 寄存器将数据写入内存中
                       
           线程安全问题 （竟态问题）： 在执行步骤三前有另一个线程开始步骤一。
           
           
67. 同步和互斥：
     
     互斥：保证多线程不能同时进入临界区。
     同步：多线程之间有执行顺序依赖
     
     锁：解决互斥问题。
        
        忙等锁（自旋锁）：若锁被占用，调用者不会睡眠，而是一直循环等待锁的释放。 占用cpu
        互斥锁： 锁被占用，调用者陷入睡眠 
        
        自旋锁可用条件变量替代，取消忙等。  信号量
        
        
68。 哲学家进餐问题：
              
              信号量+互斥锁   ：  互斥进入临界区； 信号量模拟拿左叉，拿右叉，放左叉，放右叉。
     
              think();
              P(mutex);
              P(fork[i]);
              P(fork[(i+1)%n]);
              eat();
              V(fork[i]);
              Vfork[(i+1)%n]);
              V(mutex);

69. linux内存 段页式存储：
      分段：将程序内存按物理内存顺序存储，但是容易有内存碎片（外部碎片）。
      分页：将程序分称逻辑页，每个页通过页表对应物理位置。但是容易产生页表覆盖问题。
      
      段页式：弥补两者缺点，  在按顺序分称段的前提下，在段中分成多个页。
      
      linux：程序段，初始化数据段data，未初始化数据段bss，堆，栈。

70. TLB：
      页表缓存，省去了到内存读页表的步骤。


71. 乐观锁，悲观锁
    
    乐观锁：总是认为数据不会改变，不用必须加锁，只有当数据真改变了，再进行回滚操作。
    CAS：乐观锁的实现方式之一，轻量级锁。
         读取数据时不加锁，准备写入数据时查询比较原值，如果修改了，则重新读数据。  （比较+更新是原子操作）
         核心基于数据版本记录。
         
         无锁队列通常通过CAS来实现，通过模拟链表来实现队列，保存链表头id，尾id，以及数组data
         
         问题：CAS操作一直回滚的话，会造成自旋状态，占用cpu资源； aba问题，可能造成反复读写，但结果没变，线程查不出来。 a->b->a（加时间戳）
         
    悲观锁，总是认为数据会发生竞争，所以每次读写前都要加锁。
    synchronized 互斥锁
    

72. c++ 多态：
          多态就是指多种状态，通常分为静态多态和动态多态。
          静态多态发生在编译期，通过函数重载实现，相同的函数名，不同的函数形参。
          c++多态一般说的都是动态多态，发生在运行期，通常通过虚函数来实现，基类指针指向派生类对象，调用函数时会按照动态类型（派生类）来调用实际函数。
          
    虚函数：由虚函数表来实现。
          整个动态多态就是一个三级指针结构。
          
          首先，要有一个基类指针指向派生类对象。发生虚函数覆盖。
          其次，派生类对象在构造的时候会创建一个虚函数指针指向派生类的虚函数表。
          最后，每个多态继承系统下的类都会维护一个虚函数表，虚函数表中存放的都是函数指针，也就是实际函数的地址。
    
73. c++新特性
        移动语意，move，右值引用； lambda； auto； 智能指针shared_ptr ；stl容器
         

74. c++内存泄漏：
        解决：使用对象来管理资源（RAII），c++11中引入了shared_ptr 引用计数。
        内存泄漏排查：linux： valgrind


75. 海量数据 ， 内存有限 排序：
    
    多路归并：分治策略，将数据分成多组，分别在内存中排序； 在通过中间数组来多路合并。
              内存中维护一个数组，大小为分组数。每次都将组中的最小值放进去，进行数据交换。
              

76. c++ 类型强转：
    1. const_cast：将const转为non_const。
                  volatile：告诉编译器不要做缓存优化，每次进入内存读数据。可通过 const volatile 改const值
    2. static_cast: 用于隐式转换，可将non_const转为const； 有安全隐患，类型不安全，可以将基类指针转为派生类指针。
                    
    3. dynamic_cast：安全向下转型， 基类指针转为派生类，类似虚函数会用RTTI运行期检查类型，确认动态类型。
    
    4. reinterpret_cast：低级转型，可以将 int指针转为int，不常用。

77. 野指针和悬空指针：
    悬空指针：指向的对象已经销毁，指针指向的的是一块空地址。
    野指针：指向的内存已经销毁或受限，不能用null来探查。
          野指针产生：1. 指针未初始化，随机指向内存。
                    2. 指针释放后，没有置空。 例如，在free后应该将指针设nullptr，否则会造成内存混乱。
                    3. 指针超越变量作用范围。
          避免：初始化nullptr，释放置nullptr。


78. linux 4g内存布局：
          用户态：内核态 3:1
          用户态：栈，   堆，bss，data，text       命令行参数，环境变量
                  bss未初始化数据段，只有虚拟内存，没有物理地址，不会缺页中断，返回全零页
                  
                  malloc从堆中分配内存  brk（）返回指向大小合适的堆线性区指针，等实际用的时候再分配物理内存。
          内核态空间： 虚拟高  物理低
          
          
                vmolloc:为了避免外部碎片，类似用户的分页式存储，将虚拟内存与物理内存分解，通过tlb页表来找物理内存位置。
                kmolloc: 通常请求小于一页的连续内存，通过slab分配器来避免内部碎片。
                

79. 分布式锁：
          通常互斥锁等线程级别的锁都是在同一进程，统一机器中，互斥进入临界区。
          分布式锁是分布式系统的概念，数据存放在不同的服务器 机器中，相同的成员 变量 在不同的机器中都可能有副本。
          所以需要跨机器的互斥机制。
          
          基于数据库， 基于redis缓存， 基于zookeeper
          reids：   setnx加锁， expire设置超时时间， delete 删除锁



80. socket函数：
    
      socket(family, type)  协议族， 套接字类型。
      
      connect(sockfd, servaddr, addrlen)   套接字描述符， 服务器地址， 地址结构    三次握手完成连接
      
      bind(sockfd, addr )  绑定端口 ip
      
      listen(sockfd, backlog)  
      将主动套接字转为被动监听套接字
      维护两个队列， 一个connect队列， 一个accept队列。
                                队列之和不能超过backlog
       accept(sockd, cliaddr) 利用监听套接字， 从accept队列取出一个连接                      
 
       close(sockfd):
                  和tcp连接close有区别，  socket close函数 在多线程中是减少对sockfd的引用计数，并不是直接关闭
                  tcp close指的是 四次挥手，关闭连接
                  
       shutdown（sockfd, howto）:
                  没有引用计数，可直接关闭
                  可以选择关闭方向，0,1,2 读，写，读和写。
                  
       
81. 红黑树
        目的是平衡搜索二叉树； 根，叶必须黑； 红色节点的子节点一定是黑； 
                              *每条路径上黑节点数量一致   保证最长路径不会超过最短的两倍。
                              通过旋转， 变色可以达到满足性质，达到平衡。
        
82. cpu排查：
    top -c：查看当前进程列表， 找消耗最高的进程
    top -hp (进程号) 找消耗最高的线程。
    导出进程快照 jstack
    cat | grep 查看进程线程内容
    

83. 多线程并发:
    
    cpu寄存器， 高速缓存， 内存， 磁盘
    
    高速缓存：为了中和cpu和内存之间的访问速度差异，可以减少内存io操作，将cpu常使用的资源放到缓存之中。
    
    cpu-线程运行模型： cpu寄存器读取内存中变量，寄存器修改变量， 将变量返回内存。
    
    原子性：操作要么全部执行，要么全都不执行。
    
    死锁条件： 1. 互斥:一个资源只能给一个进程。
              2. 占有等待：一个进程在持有资源情况下还可以申请其他资源。
              3. 不可抢占；不能抢占已经分配出去的资源。
              4. 环路等待：进程对资源的需求形成环路。
    
     
    线程切换条件：
            1.正常cpu时间片轮转调度。
            2. io阻塞会被挂起。
            3. 并发任务抢占锁
    
    线程安全：内存共享带来的一致性问题。 竟态条件，多个线程并行可能共同操作一个变量。 
    
    
    
 84   分布式架构：
    
          单一应用架构：将所有功能放到同一个应用服务器中。耦合度高，可用性不高。
          微服务：将功能拆分， 每个功能可能有自己的应用服务器，数据库。降低了耦合度， 扩展性强。但是功能之间可能存在联系，需要严格设计。
                  注册中心来记录所有的功能拆分。  重试机制，熔断机制，
                  
                  1.服务上线顺序，2. 服务回滚计划 3. 服务团队之间的合作依赖
           
           soa面向服务架构， 企业级别的面向服务概念；   微服务是应用级别的面向服务。   
                  
                  
      分布式事务（数据库）
          2pc 二阶段提交：通过一个中间层，协调者来管理事务提交返回。 同步阻塞过程。
                        准备阶段：协调者统筹安排各数据库将结果先准备好，并不急着返回。阻塞
                        提交阶段：所有数据库都准备好后，再统一返回结果。 如果有一个失败，则整个事务失败。
                        协调者可能会挂掉，在不同的时间都有不同影响，要采用选举出新协调者。
                  
          3pc 三阶段提交： 改良版，引入了超时机制。
                        准备阶段：只是负责询问各数据库参与者状态情况；  不会直接上锁阻塞
                        预提交阶段：告诉数据库开始准备数据， 阻塞， 还多了一个超时机制， 如果阻塞时间长，认为事务无法提交，自动解锁。
                        提交阶段：提交结果


85. 秒杀系统等 电商场景常见问题：
      高并发: 时间短的情况下 用户量极大。 无论是对功能性的服务器， 缓存服务器，还是分布式数据库 都有可能造成冲击。
      
      超卖：并发业务问题
      
      恶意请求：脚本控制模拟出大量用户加入并发。
      
      解决：限流， 前端限流和后端限流。
                  前端在不到时间根本就不给接口； 即使接口可以点击了，一般一段时间只可以点一次，即使一直点也不会响应。
                  后端在秒杀数完成后直接通知前端，关闭掉了秒杀窗口。
            
            降级；将其他不想关或者影响度低的业务先降级， 优先处理当前系统。
            熔断：将系统抽离，不能影响其他正常的系统。
            隔离：系统不能再调用其他系统的功能。
            
            
            消息队列：负责功能解耦和削峰。
                    生产者消费者模型，客户的请求订单当做生产者，服务器处理订单相当于消费者。通过中间层实现了功能的异步实施。
                    同时在消息队列中，也可以解决很多系统设计的问题，比如重复消费，消费的顺序等业务问题。
            
            nginx负载均衡服务器， 高新能web服务器。
      
            坚持微服务架构，单一服务原则： 提交整个系统的可用性和分区容忍性
            
            redis集群： 将缓存数据分配到不同的redis服务器节点上。不同节点存不同数据，每个节点还通过主从复制来达到读写分离，哨兵模式来
                        控制master的保活，数据通过一致性哈希存放在哈希环上，每次插入 删除节点 都不会对全局数据造成影响， 虚拟节点的
                        设计也解决了一致性哈希的不均匀问题，每个实际节点都可以映射成为多个虚拟节点，虚拟节点不挨着，这样数据就能达到均匀。
                        
            缓存预热： 刚开系统不能直接去数据库找数据，要先将数据放到缓存。
            

86.       分布式锁
          通常互斥锁等线程级别的锁都是在同一进程，统一机器中，互斥进入临界区。
         分布式锁是分布式系统的概念，数据存放在不同的服务器 机器中，相同的成员 变量 在不同的机器中都可能有副本。
          所以需要跨机器的互斥机制。
          
          基于数据库， 基于redis缓存， 基于zookeeper
          reids：   setnx加锁， expire设置超时时间， delete 删除锁

          实现原理： 使用zookeeper管理分布式锁，实现互斥。
          
          缓存，数据库读写一致：一般来说，完全一致很困难，允许一定的误差。每次更新时还要再返回查看一下原
                              数据时间戳一不一致，不一致就停止更新。
                              也可进行读写串行化：把所有操作放到一个队列中。
          
                              当更新数据库时，一般直接删除缓存；不用每次更新都做计算


87. epolloneshot: 在多线程中，可能会有多个线程在wait 同一批io调用， 当一个线程没处理事件，另一个事件触发，
            这时会有一个新的线程又将原来的那个io事件重复消费。
            oneshot就是声明了该描述符注册的事件只能被消费一次，如果要重新触发，要调用epoll_ctl重置事件。

88. 数据库设计思路：
    树形结构，分类 上级类别 外键
    
  
  
  89. 条件变量 加锁：   条件变量本身就是公共资源，可能线程不安全，去要加锁保护 其实也是为了保护布尔表达式。
  
      条件变量 while：避免虚假唤醒。 原因主要还是 notify不在生产者的临界区
      
90. 线程安全hashmap ，lru
                  
                  双层哈希表， 一个总哈希表，对应多个子哈希表，再使用分段锁

91. 僵尸进程回收，避免


92. 数据库三范式：
            1. 属性不可分
            2. 属性依赖于主键
            3. 不传递依赖。
            
        目的：解决4种异常问题：1. 数据冗余。
                              2. 修改异常。修改了一个记录，另一个纪录信息没修改
                              3. 删除异常： 删除一个信息可能造成其他信息也被删除
                              4. 插入异常：
  
93. 唯一索引和主键索引：
          主键索引属于唯一索引特殊类型， 不允许两行有相同索引， 定义一个主键将自动创建主键索引。
          
          1. 主键不一定只包含一个字段。
          2. 主键不允许空值；
          3. 主键索引只能有一个
                
                
94. socket 读写返回值：

        大于0时： 从缓冲区中读取或写入的字节数
         read等于0： 表示对端已经关闭socket ，缓冲区没有数据可读
         write等于0：缓冲区已经满了，目前写不了
         
         返回-1： 出现错误，要判断errno：  EINTR:系统当前中断，可忽略
                                          EAGIAN： 阻塞操作超时，需要关闭重连； 非阻塞忽略
                                          EINPROGRESS：非阻塞：正在处理中
         epoll  ET模式下，只能用非阻塞模型，机制就是当有事件触发，必须要马上处理，否则下次不提醒
         当等待写入操作时效率高，触发少。 但因为非阻塞的要求，一次读写要完成，也就是read和write要
         到返回-1. 这时候只有非阻塞允许，阻塞只有在超时才会返回-1.
         LT模式无所谓 返回值， 因为只会调用一次，如果没完成的话，下次还会提醒。
         
95. socket tcp 保活keepalive机制：
        连接没有主动关闭，查看是否还可以继续交互。
        空闲存活7200秒， 开始探测，重传9次，间隔75s
        
        
 96. 网络字节序： 大端   把收到的第一个字节当做高位字节对待。
 
 大端模式：高地址存放低字节顺序，  类似栈的增长方向
 小端模式： 低地址存放低字节顺序   类似堆得增长方向
                
                int n= 0X11223344;
                char* c= (char*)&n;


97. 线程同步方法：
      1. 互斥锁：
      2. 条件变量：
      3. 读写锁：
      4. 信号量： 不用
                
                
                
98. 用户上线下线时间， 统计每个时刻在线用户数量。  用户上下线：[Si, Ei]

     维护三个数组： 在线用户数 num[24*60*60]
                   登录用户数 online[86400]
                   离线用户数 offline[86400]
      对于每个用户： online[si]++;  offline[ei]++;
      
      num[i]=num[i-1]+online[i]-offline[i];                                                                                


99. 海量数据存储id，信息：
                      先考虑哈希
                      在考虑跳跃表实现 对id进行排序。   占用空间大，需要额外空间记录跳表信息。
                      持久化问题：rdb：记录数据快照，再传到磁盘
                                 aof：每次更新记录日志，可以频繁记录，可靠性更高
                      而且数据不能全存内存上，肯定会有lru缓存置换操作
                      
100. 实时排行榜：
            跳表， （单链表或双链表）
            1. 多级指针实现：从最高级指针开始查找，不同的指针代表了不同的跨度
            2. 随机等级机制：更便捷的插入 删除，
                            排名需要在每个节点增加跨度值，查找中做一个累加，并且记录搜索路径。
                            这个跨度值是在创建跳表，插入新节点的时候进行更新。
            记录用户是否投票：位图法，每个用户id对应一位，投票了就变成1.
                      
                      
 101. 全局变量和static变量：
      两者都存在静态存储区中，未初始化自动0.
      全局变量作用整个工程，而static变量限定了作用域，函数，类或文件。
      
 
 
 102. 拷贝构造函数：通常需要加explicit，不允许隐式转换。
              *编译器什么时候不会合成构造函数： 1.当显示声明了移动构造函数 2. 当有的成员不支持拷贝。
              *成员不能拷贝：拷贝构造函数不可访问，或者析构函数不可访问。
              
              const &： 防止无限递归构造
              
 103. 移动构造函数： 通常要加noexcept，和析构函数一样，涉及到内存管理，如果抛出异常会导致内存泄漏。
 
              *编译器什么时候不合成移动构造函数：1.显示声明拷贝构造函数，2. 声明析构函数  3. 成员有const，引用
              
 104. 一定需要初始化列表：const, 引用， 无默认构造函数的成员。
                                 
 105. 派生类析构顺序：先析构基类部分，再按成员初始化逆序析构成员， 最后析构自身。
              
 
 106. 虚函数缺省参数值： 静态绑定，无法定位到派生类缺省参数
 
 107. 纯虚函数：不能实例化对象，但可以用作句柄（指针，引用）来实现多态。 当做基类指针。
 
 108. 深拷贝，浅拷贝：
            深拷贝会拷贝指针指向的对象， 会另外申请内存来拷贝指针指向的对象。
            
 109. 内存对齐：
            struct大小为最大成员大小的整数倍
            成员的首地址距离结构体首地址偏移量，一定是其类型大小的整数倍。
  
  
 110. auto 关键字： 利用RTTI 运行时类型识别。 typid
                    对于有虚函数的类，在运行期执行RTTI，找出动态类型；
                    没有虚函数的类，在编译器就可以执行RTTI，返回静态类型。         
              
 111. 死锁条件： 互斥， 占有等待，不可抢占，环路等待
                      
                      
 112。 kafka
 
        1. 为什么快：
                  1. 磁盘读写； 并且采用了顺序写入的原则。磁盘保证了数据不会丢失，顺序写入避免了寻址的时间。
                              每个partition都是一个文件，消息写入在文件末尾。
                              *kafka无法删除数据，每个消费者对topic用一个offset记录读取到了第几条数据。
                              offset由客户端保存
                              
                              kafka删除数据避免硬盘空间占满： 基于时间，基于partition大小
                              
        2. kafka与其他消息队列区别：
                kafka特点：高吞吐。
                1. 顺序读写操作，offset记录位置，不能删除
                2.磁盘存数据，不丢失。
                3. 支持批量发送，消息可以缓存在生产者本地，批量发到kafka中。
       
       3. kafka保证消息队列不丢失：
                1. 重传机制， ack
                2. 天然分布式，每个topic分成多个partition, 在其他topic中有partition的副本
                3. 存在磁盘上，持久化。
                

113. 图的存储方式：
                1. 邻接矩阵，二维数组存储：    不合适 边少的情况 浪费内存
                2. 邻接表：    顶点用链表存储
                3. 边集数组：
                4. 十字链表：
                5. 邻接多重表：

114. hashsize要用素数： 根本上是减少哈希冲突， 降低多因子带来的余数影响。


115. 两个类互相引用： 1. 头文件互相include
                     2. 头文件不能实现函数，尤其是不能使用对方的成员
                     3. 用代码文件去实现函数。
                     
115. utf-8 和 utf-16:
       字符编码方式， 一个字节，8比特位 表示一个可变长字符，保留了 ASCII编码；
                     两字节，16比特位；


116. linux下内存泄漏检测： valgrind 检查 malloc和 free，  new 和delete是否匹配。


117. 浮点数求平方根：
          去一个小double阈值 e=0.000001；
              while((r-l)>e){  m=(l+r)/2;  if(m*m>x) r=m; else l=m;      }


118. c++ open(), close():
        没close坏处： 当程序崩溃时， 之前的读写可能全部造成失效。
        

119. TCP粘包解决：
        在字节数据流内容中， 自定义数据包头， 包含数据包长度


120. vector:  insert:  (iterator, int n, Type t)   都是对迭代器进行处理
              erase:

121. 查看数据库查询是否用到索引：
              explain


122. stl容器 动态链接问题：
              stl全都是基于模板的，模板是在编译器生成的。这也就是说同一份stl代码在不同动态库中
              有各自的实现，如果只是方法多了一份自然就没问题，但是部分stl容器里面存有一些静态变量，
              因此多个实现会导致多份静态变量，然后导致某些方法的调用出现差别，最终导致内存操作异常而
              崩溃。
              
              
123. nullptr调用成员函数：
        成员函数调用模型都是可能通过this指针对 对象进行改变
        1.当非虚函数 且不涉及this指针，可以调用
        2. 非虚函数 涉及this指针，不调用
        3. 虚函数   一定不调用  无法找到vptr
    
    
124. set迭代器的++ --操作：
      红黑树属于双向迭代器，不具备随机定位能力。
      ++调用基类迭代器incremen， 后退调用基类迭代器的decrement，根据二插搜索树序列
     




125. mysql 事务隔离级别的实现：
        mvcc：多版本并发控制，innodb实现隔离级别的具体方式，实现提交读和可重复读。
              copyonwrite思想 每个数据行都有两个隐藏列：事务版本号，过期版本链，用指针指向上一个版本的位置
              
              通过undo日志找到老版本
              readview：
              如果访问的版本号低于当前版本号 那就说明事务已经提交了，达成提交读
              提交读会更新版本号，而可重复读不更新版本号
        大多数情况下代替了行锁，没有阻塞，适合大并发场景      
 
      
126. mysql 引擎区别：

          InnoDB：事务级的引擎，可以commit提交，回滚；四个隔离级别，ACID兼容；   支持行级锁和表级锁； 
                  支持聚簇索引，索引中存数据，避免读磁盘。
        
          myisam：非事务级引擎，事务不安全，可以提供高速的存储检索，全文搜索，适合频繁查询； 只支持表锁；
                  记录了行数，适合count计算
        
        
127. placement new：
          在已经分配的内存中创建对像， A* p =new(ptr) A;   ptr: 指定的内存首位置
          


128. time_wait 为什么2msl：
            msl根据ttl来判断，ttl存储路由器跳数，msl存时间
            2msl是因为：可能网络中还存在发送方的数据包，到达接收方还会产生回应，又要消耗一次msl


129. linux 硬连接 软连接：
          连接是一种文件共享的方式， 底层实现原理不同
          
          硬连接通过索引节点进行连接，可能多个文件指向同一个索引节点。 允许一个文件有多个有效路径名，防止重要文件误删。 引用计数 （）
          软连接（符号链接） 类似快捷方式，文件中保存的是另一个文件的位置信息。（指针）
          
          
130. accept惊群，epoll惊群:
          
          当进程线程同时阻塞等待同一事件，事件发生唤醒所有进程，但最终只有一个进程进行处理，其他
          进程继续休眠，造成性能浪费。
          accept惊群：listen管理两个队列，accpet队列表示完成三次握手的连接，当accept队列为空，
          accept函数就会造成阻塞。 目前内核已经解决该问题，每次新连接进来只会唤醒一个进程，其他保持休眠。
          
          epoll惊群：多进程阻塞在同一个socket fd的epoll wait上，当新链接进来，所有进程可能唤醒。
          
          niginx解决： 不做同时监听，而是每个进程轮流监听。  利用一把进程间的锁。获得锁的进程可以将监听socket
          加入到wait集合之中。
          
131。 epolloneshot：
          多线程处理会出现的的竟态性问题，当一个线程处理socket但没有完成的时候，又有新数据到来触发
          ，另一个线程可能又会拿到相同的socket，即使et也会出现。
          epolloneshot  注册的事件只会发生一次，要重新调用epoll_ctl重置事件。
          
          
132. 缓存击穿 和 缓存穿透：

        缓存穿透： 数据库中没有数据，缓存中也肯定没有记录。
                  id校验，没有的话直接返回空；   布隆过滤器，散列函数
                 
        缓存击穿： 数据库中有但缓存中没有（通常因为过期）。
                  热点数据不过期；  互斥锁
                  
                  
133. INT_MAX : 0x7FFFFFFF       7:0111    F:1111         
              

134. 常见信号： sighup挂起进程   sigint终止进程    sigkill杀死进程   sigstop停止进程


135. 网络端到端 点到点：
        
        端到端：网络层，主机之间的通信，是逻辑链路 靠端口号来进行传输
        点到点：物理链路层， 同一链路下主机通信， 物理链路， 


136. redis缓存一致性的问题：
          直接删除失效缓存
          更新失效缓存
          
          先更新数据库，再删除缓存：容易造成数据不一致。
          先删除缓存，再更新数据库：数据一致，但容易造成缓存击穿，大量访问数据库

137. 线上服务监控指标：
        qps并发量；  pct可用性 999；  cpu   内存水位     磁盘io   网络io
        
        

138. tcp保活机制：
          7200s    75s  9次
          
          1. 对端正常到达，同时正常响应，保活时间重置
          2. 对端崩溃，探测报文无法达到， 重试几次后，报告连接死亡，断开连接。
          3. 对端崩溃但是重启， 这时候丢失链接信息， 对端会返回rst报文，进行连接重置
          

139. 快速中位数：
          通过快速排序法， partition找到pivot，再通过getk  判断pivot和k关系



140. 数据库知识点：
        innodb：事务型存储引擎，支持commit 回滚；  mvcc实现隔离机制，支持高并发。
                mvcc+next-key locking 防止幻影读
                
                聚簇索引，索引保存数据行，防止进入磁盘寻址
                
        myisam：设计简单，  适合表小，只读。
                不支持行锁， 不支持外键

                支持全文索引， 查找文本关键词   match against
                空间数据索引， rtree
        
        覆盖索引： 索引包含所有要查询的字段
                  若辅助索引能够覆盖索引，无需访问主索引 回表。
                  
        explain： 分析select语句性能
        
        
        mvcc：多版本并发控制， 实现2 3隔离的机制。
              通过两个隐藏的列：  当前事务版本号（事务开始时系统版本号），  过期版本链
                


141. https中间人攻击：
        ssl劫持攻击： 攻击者伪造ssl证书欺骗，接入到服务器，客户端连接之间，伪造证书作为公钥，即使客户端发现证书错误
                      也可能因为安全意识薄弱而忽略提示。
                      
        ssl剥离攻击： 中间人和服务器保持https通话，但是和客户端用http明文传输。
        

142. sql注入：
        网络攻击方式，通过sql语句实现无账号登录，甚至篡改数据库。
        
        1. 寻找sql注入位置
        2. 判断服务器类型和后台数据库类型
        3. 针对不同类型sql注入攻击

        构建特殊的输入（sql查询组合）作为输入参数传入web应用。 攻击数据库服务器。



143. 32位系统  64位系统内存布局：

        32位：4g内存  1:3
        
        64位：2^64  基本无限内存
        
        
        
144. c++ 向上转型  向下转型：
        向上转型：派生类指针转基类指针，安全的；
        向下转型：基类指针转为派生类指针， 不安全，数据丢失，内存泄漏。 
        
        static_cast 可用于向下转型，不保证安全性。
        dynamic_cast 主用于安全向下转型, 支持运行期识别指针引用（动态类型）
                      检测对象是否可以安全的转换成target类型
        
 145. DNS使用协议：
        
        TCP和UDP：  
                  dns区域传输时使用tcp（数据同步）  辅域名服务器向主域名服务器查询
                  数据是否变动。
                  域名解析时使用udp  一般内容不超过512字节



















        

