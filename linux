一. 文件管理：
    1. 文件查找   find+目录+条件
    2. 文件拷贝   cp+源+目的
    
    3. 打包解包：tar    -z -j -J    zip bzip2 xz
    
二. 文本处理 （管道命令）
    1. 查看文件(显示行号）  nl
    2. 文本查找：  grep  正则表达式全局查找并打印  -i 忽略大小写  -n 打印行号  -c 统计次数
    3. 排序： sort -d -n -r
    4. 转换（字符）： tr -d删除字符   -s字符压缩
    5. 切分文本：cut  -d 分隔符    -f 选择域   -c字符范围
    6. 拼接文本： paste  -d 分隔符
    7. 统计 wc  -c字符数 -w 单词数  -l 行数
    8. sed 常用与一整行的处理   -a在后插入   -i在前插入    -d删除
    9. awk 常用与处理小段数据  $0 一整行，  $1 。。。。 按字段取
三。 文件内容
    1. 打印文件内容  cat
    2. tac  从后往前打印
    3. more 可以一页一页查看，适合大文件
    4. less 还可以向前翻页
    5. head 文件前几行
四。 指令与文件搜索
      1. which  指令搜索
      2. whereis 文件搜索 通过目录
      3. locate 文件搜索 正则表达式，关键字
      4. find 文件搜索  通过属性 权限
      
      
五。性能分析  进程管理
    1. 进程查询 ps  -l  自身相关的进程   aux  所有进程   aux｜grep  查看特定进程
 -l：   F：进程标志，权限    S：进程状态   C：CPU使用率  Time：进程用掉cpu时间
    
    2. 进程监控：top  实时显示进程信息   -d隔秒数更新
    
    3. free 内存使用量
    
    4. lsof  查看打开文件
    
    5. shell 进程资源限制  ulimit  -n可打开最大文件数
    
    6. fork vfork clone  创建子进程
    
    7. init进程  第一个用户级进程， 相当于进程树的根
    
    8. pstree 进程树
    
    9. exit（） _exit（）   进入内核
    
    10. netstat 查看占用端口进程（socket连接）  -a查看所有连接 -t tcp连接 -u udp连接   -n 显示端口号 -l 列出监听状态 -p 显示pid
    
    
六。 开发 调试
    1. 编辑器vim
    2. 编译器 gcc g++
    
    3. 调试工具 gdb      1. 得到可执行文件  gcc -o可执行文件     -g源文件
                        2. 启动 gdb
                        3. gdb命令   r:运行程序  q：推出gdb  b：设置断点    c：继续执行   s：执行一行    n：执行一行，不进入函数  
    
    
    

linux 初级指令：
        1. ls 列出目录下的文件
        2. pwd 当前目录的完整路径
        3. touch 修改文件时间属性，若不存在文件 新建。
        4. cat 打印文件内容   tac 反向打印
        5. mkdir 创建目录 
        6. cd 切换目录
        7. rm 删除文件  rmdir删除目录
        8. mv 文件或目录的移动  mv source target    也有重命名作用
        9. cp 拷贝文件内容
        10. echo 字符串标准输出
        11. head/tail  文件的前几行，后几行
        12. more less  可以分页查看文件内容， less可以向前翻页。
        13. wc 统计文件（行数，字节数，字数）
        14. date cal   时间和日历
        15. which  搜索指令
        16. whereis 用于程序名的搜索   通常用过目录
        17. nl 查看文件内容，加上行号
        18. ps 查询进程  -l：自身相关进程    -a全部进程
        19. kill 发送指定信号给指定进程      kill-l查看信号
        
linux进阶命令：
        1. find 搜索文件， 通过属性，权限
        2. grep 正则表达式
       



linux文件类型：
        普通文件，目录文件，块特殊文件（带缓冲访问），字符特殊文件（不带缓冲访问），fifo管道，套接字，
        
        
        
        
c程序空间布局：
        栈->（内存空隙）       堆-> BSS-> DATA-> TEXT正文段
        
每个程序还有环境表，存在高地址（头部）。


linux通过exec函数执行c程序，先开启启动例称，准备环境变量，和命令行参数。 在通过exit结束程序。

exec不开新进程，只是替换当前进程内存资源（text，data，堆栈）







linux程序共享库：
        静态链接：编译器链接，文件体积增大，运行的时候不需要再读取外部库
        动态链接：运行期链接，到使用时再读取外部库
        

进程堆管理：
        brk（）函数可以抬升堆地址，分配虚拟内存。 此时并没有分配物理地址，当进程实际调用该地址时才会分配物理地址
        
        c库函数malloc，free管理堆：
            通过内存列表来管理内存；接口简单；
            malloc还会额外分配字节来记录内存的大小，目的是便于之后的释放。
            free使用内存块存放内存列表的指针，调用时将自身添加到列表中。
            
        


coredump：程序异常，崩溃时的内存快照。 内存信息，寄存器信息
            通常是程序内部错误，但捕捉不到异常； 有可能：堆栈溢出，取位异常。。。

            ulimit -c unlimited：产生coredump
            gcc -g 打开gbd， gdb program core 查看coredump文件
            
linux进程控制：
        特殊进程：
                0进程：调度进程，内核一部分。
                1进程：init进程，用户级进程，但有特权；在系统开始时就会由内核调用，作为进程树的根。
                
        进程创建：
                fork：子进程倾向于复制父进程的资源，有的采用写时复制，如果没有写操作，就直接调用父进程资源；写操作时更新。
                
                vfork：倾向于直接共享父进程资源，在父进程空间运行。
                       保证子进程先运行。只有子进程退出，父进程才能继续调度运行。
         进程终止：
                子进程exit， _EXIT返回退出状态     父进程wait， waitpid  回收状态
                
                父子进程退出异常：
                        僵尸进程：子进程退出，父进程没有wait回收子进程状态，导致子进程的id等终止状态信息存在系统中。
                        孤儿进程：父进程先退出，子进程无法向上回收状态。 这时init进程会回收孤儿进程。
                        
linux线程：
         pthread_create
         pthread_join  线程回收，将子进程资源返回主线程
         pthread_detach 线程分离，资源直接释放，不等子线程完成。  即使线程终止了，也不回收资源。
         
         线程结束：
                pthread_exit  关闭自身
                pthread_cancel 关闭进城内其他线程
                线程自身return 完成函数
                进程exit
                
linux 线程同步：
        互斥锁：mutex  lock_guard  unique_lock
        读写锁:  共享锁，互斥锁
        条件变量  conditional_variable，优化自旋锁，在某条件发生前，将线程睡眠，wait等待唤醒。
        自旋锁：获取锁之前一直等待轮训，只适用于锁时间不长的场景。
        屏障： 多线程同步机制，等所有合作线程到达才会继续执行
         
线程调用fork创建子进程：
        子进程内部只会存一个线程，这样，可能会有锁的影响。子进程不知道其他线程持有什么锁。
        
linux存储映射：
        mmap：将磁盘文件映射到进程缓冲区        
                
                
                
                
            
        
