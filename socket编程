1. socket: 五元组 （id，本地ip，本地端口，目的ip，目的端口）

2. 字节序：
    大端：低序字节存在高地址
    小端：低序字节存在低地址

3. connect：三次握手
      客户端发起connect连接，syn=1 tcp数据包，
      服务器端listen监听到连接，将该socket放到连接队列中，并返回一个syn=1，ack=1 tcp数据包；
      客户端收到后，还要返回一个ack=1数据包；
      服务器收到后，讲socket移动到accept队列中，accept函数可以从该队列中获取连接，以便完成数据传输。
      
      syn包可以包含mss，最大字节长度。
4. 缓冲区：
      每个socket都有一个发送缓冲区和一个接收缓冲区，
      
      进程->进程缓冲区->socket发送缓冲区->封装ip数据包,向下传递->传达对端
      
      socket缓冲区：1. （tcp阻塞）有大小限制，一般MSS，当进程缓冲区大于socket缓冲区，会阻塞进程write，write要把进程缓冲区数据打到发送缓冲区中；
                    2. 有数据备份功能，只有当收到ack才会在缓冲区释放数据；
                    
      进程缓冲区： 有效减少实际io次数
                  1. 防止进程总要陷入内核
                  2. 防止读取数据不足一个包，或大于一个包，缓冲区可以对分包，粘包做处理
                  
       低水位：只有数据一定量，才能读
                只有空间有一定余量，才能写
                
5. socket：
      制定一个文件描述符，（协议族，套接字类型type）
      
6. bind：
      给socket绑定ip和端口
      
7. listen：将套接字转化为被动套接字，做监听工作，指示内核接收连接请求。
            维护两个队列，一个connect队列，一个accept队列。
            可以设置最大排队数。
            
8. accept：从accept队列中取下一个连接，以便完成后续数据传输


9. close：socket 的close行为和 tcp的close行为不同。
            socket close仅仅是减少对socket的引用计数，当计数0才会关闭连接。 引用计数目的：多线程中，线程会共享进程的资源，包括socket，增加引用计数。
            tcp的close是真正的四次挥手关闭连接。
            
            tcp关闭：优雅关闭：四次挥手，close_WAIT 等待缓存数据发送完。
                    强制关闭：没有 close_wait 直接返回，

10. shutdown ：shutdown与引用计数无关，可以控制连接关闭方向。0：关读，1：关写，2：都关

11. getsockname: 返回套接字的本地协议地址
    getpeername: 返回套接字的外链协议地址（服务器找客户端身份）
    
    
12. io多路复用：
    同步io机制，避免大量线程的开销。
    通过一个线程中的描述符来监视多个io操作。（读写）
    select poll epoll 
    
    select：io描述符数量有限制，且每次io触发，内核会将所有io描述符返回，触发轮训，查具体哪socket被触发。
    poll：取消数量的限制
    epoll：取消数量限制； 维护一个就绪队列，每次内核只会返回触发的描述符。
    
    epoll模式： lt水平触发：默认模式，支持阻塞和非阻塞； 每次有描述符触发，可以选择不立即去处理，将描述符再放回就绪队列，下次再触发还会返回该描述符。
                et边际触发，支持非阻塞；描述符触发必须马上处理，否则不再提醒。所以要求一次处理完io。一直读写直到eagain。
                
                et模式保证一次读写完整， lt模式需要另外监听epollout是否读写完成。
                
                lt编写简单，符合思维，不易发生遗漏
                et编写困难，但触发次数显著减少，提升效率。
                
                
    连接少且活跃，用select和poll效率更高。
    
