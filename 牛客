1. 数学公式： <math.h>      fabs    sqrt    ceil   floor   

2. 保留小数点：
  <iomanip>
      cout<<setiosflags(ios::fixed)<<setprecision(2)<<
      
  <stdio.h>  
  printf("%.2f\n", sum);
      
3. 多组输入：
    while(cin>>   )
    
4. 







剑指offer

11. 旋转数组 ：  二分法 （模版）    

int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
        }
    return -1;
}



int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {  //这里很重要
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}



int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;
    
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return right - 1; // 注意
}



   26. 树的子结构  双递归。
    递归思想，如果根值不同一定不是子结构， 再查左节点和右节点。

}

29. 顺时针打印

30. 包含min 的栈    辅助栈
        当小于top时入栈，当等于stack时出栈。
        
        
 31. 压栈 出栈     辅助栈  根据push找pop栈位置   当找到相同的值，pop右移辅助stackpop(). 
 
 34 后续遍历？    单调栈
 
 35 链表深复制
             利用 hashmap
             
 *36. 二叉 双向链表    递归    node* & head , node*& pre
 
 40   top k   用桶排序


13. 机器人运动范围：写一个辅助函数，获取位的和

26. 是否子树：辅助函数来判断当前节点。
              如果节点值相等，进入辅助函数判断；
              如果不相等，在主函数中继续判断左节点和右节点。
              

29. 顺时针打印矩阵：
              
33. 二叉搜索树 后序遍历：  单调栈思想，每次循环都会比较一个最大值，大于最大值时 返回false。
单调递增栈，当遇到小于top时，更新最大值。

34. 二叉树路径和

38. 字符串全排列： 可以通过set去重， 也可以设立flag 判断前面的字符是否有重复。


43 1出现的次数：迭代，while（n/i）  i*=10；
                每次计算high：高位值，cur：本位值；low：低位值
                ans+=high*i;  
                ans+=high*i+low+1;
                ans+=high*i+i;
                
44 数字序列某一位的数字：



46 数字->字符串   dp[i]=dp[i-1]+dp[i-2]


49 丑数， 动态规划    p2, p3, p5     dp[i]=min(dp[p2]*2,dp[p3]*3,dp[p5]*5);


51  数组逆序对：
              可以用归并排序，  每次把left放进去时，都会计算一次right的偏移量right-m-1，
              把这个值加到结果。
              
53. 经典二分查找    l=i;   r=j;                                                                 


56. 数组中出现 两个数没出现2次：  找到两者异或值， 再找 最近的位值为一。

57. 和为s 连续正数序列：
      i=1, j=2;    sum=(i+j)*(j-i+1)/2;       







leetcode：
      23. 合并升序链表
          分治归并，类似归并排序。
       
       22. 括号生成：
          
       33. 旋转排序数组
       
       
      36. 数独：   利用哈希表
                    row[9][9]    col[9][9]   box[9][9]
                    row[i][n]=1;     col[j][n]=1;   box[(i/3)*3+j/3][n]=1;
                    
       37. 解数独： 回溯法， 记录‘。’数组。    记录。的数量， 当。被填满后 回溯结束。
       
       55. 跳跃游戏： 贪心算法 记录最远坐标。
       
       56. 合并区间： 排序， 再比较每个区域的右边界
          
      76. 滑动窗口：
      
















