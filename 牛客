1. 数学公式： <math.h>      fabs    sqrt    ceil   floor   

2. 保留小数点：
  <iomanip>
      cout<<setiosflags(ios::fixed)<<setprecision(2)<<
      
  <stdio.h>  
  printf("%.2f\n", sum);
      
3. 多组输入：
    while(cin>>   )
    
4. stoi: 字符串转int数字

5. to_string: 数字转字符串





剑指offer

11. 旋转数组 ：  二分法 （模版）    

int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
        }
    return -1;
}



int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {  //这里很重要
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}



int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;
    
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return right - 1; // 注意
}



   26. 树的子结构  双递归。
    递归思想，如果根值不同一定不是子结构， 再查左节点和右节点。

}

29. 顺时针打印

30. 包含min 的栈    辅助栈
        当小于top时入栈，当等于stack时出栈。
        
        
 31. 压栈 出栈     辅助栈  根据push找pop栈位置   当找到相同的值，pop右移辅助stackpop(). 
 
 34 后续遍历？    单调栈
 
 35 链表深复制
             利用 hashmap
             
 *36. 二叉 双向链表    递归    node* & head , node*& pre
 
 40   top k   用桶排序


13. 机器人运动范围：写一个辅助函数，获取位的和

26. 是否子树：辅助函数来判断当前节点。
              如果节点值相等，进入辅助函数判断；
              如果不相等，在主函数中继续判断左节点和右节点。
              

29. 顺时针打印矩阵：
              
33. 二叉搜索树 后序遍历：  单调栈思想，每次循环都会比较一个最大值，大于最大值时 返回false。
单调递增栈，当遇到小于top时，更新最大值。

34. 二叉树路径和

38. 字符串全排列： 可以通过set去重， 也可以设立flag 判断前面的字符是否有重复。

*41 缺失的第一个正数：将负数先n+1 按值取负数，在遍历一次，第一个整数就是缺失的值。

*42 接雨水：    单调栈   先找底 pop， 再找左边界 不pop。


43 1出现的次数：迭代，while（n/i）  i*=10；
                每次计算high：高位值，cur：本位值；low：低位值
                ans+=high*i;  
                ans+=high*i+low+1;
                ans+=high*i+i;
                
44 数字序列某一位的数字：



46 数字->字符串   dp[i]=dp[i-1]+dp[i-2]
    LeetCode91：还要考虑‘0’的情况，当s[i]=='0'时，判断s[i-1]=='1' or '2' : dp[i]=dp[i-2]

49 丑数， 动态规划    p2, p3, p5     dp[i]=min(dp[p2]*2,dp[p3]*3,dp[p5]*5);


51  数组逆序对：
              可以用归并排序，  每次把left放进去时，都会计算一次right的偏移量right-m-1，
              把这个值加到结果。
              
53. 经典二分查找    l=i;   r=j;                                                                 



56. 数组中出现 两个数没出现2次：  找到两者异或值， 再找 最近的位值为一。

57. 和为s 连续正数序列：
      i=1, j=2;    sum=(i+j)*(j-i+1)/2;       













leetcode：
      
      22. 括号生成： 回溯法，open < n，close <open  分别对左右括号进行回溯。
      
      23. 合并升序链表
          分治归并，类似归并排序。
       
       26. 原地删除重复项： 双指针
       
       *28. strstr（）  字符串匹配， kmp算法
          
       33. 旋转排序数组:
            
            二分查找， nums[m]==target;
                      nums[m]<=nums[nums.size()-1];  target>nums[m] && target<=nums[nums.size()-1]
                      nums[m]>nums[nums.size()-1];   target>=nums[0] && target<nums[m]
       
       
      36. 数独：   利用哈希表
                    row[9][9]    col[9][9]   box[9][9]
                    row[i][n]=1;     col[j][n]=1;   box[(i/3)*3+j/3][n]=1;
                    
       *37. 解数独： 回溯法， 记录‘。’数组。    记录。的数量， 当。被填满后 回溯结束。
       
       38. 外观数列： 动态规划， 再用判断连续字符串。
       str[j]!=str[j-1] -> s+=j-i+'0'; s+=str[j-1];
       
       54. 螺旋矩阵：(剑指offer29题类似) 辅助visited矩阵， 遍历i,j...
       
       55. 跳跃游戏： 贪心算法 记录最远坐标r。当坐标小于等于r时，可以更新r；否则错误。
       
       56. 合并区间： 排序， 再比较每个区域的右边界
       
       *73. 矩阵置零：   思想：用第一行 第一列是否为0表示全数组。 但要注意，第一行和第一列matrix[0][0]
                        1. 标记第一行和第一列。 注意： 另外用一个flag存贮第一列的状态（是否有0）；
                        2. *从右下往上遍历，如果 matrix[i][0]或 matrix[0][j]==0 ,则赋值0；
                        3. 每次遍历除1外所有列后，才会判断flag：matrix[i][0]
                        
        74 搜索二维矩阵：  取左下角进行比较                
                        
          
      76. 最小覆盖子串：     滑动窗口,两个hashmap记录窗口和need。 再用变量valid记录相等的元素数量，
                          判断valid是否满足need。
      
        
        *88. 原地合并两数组： 从后往前， 双指针。
        
        *91 数字转字符串
        
        
        *94. 二叉树遍历  递归版   借助stack
        
            *后序遍历: 额外需要 pre节点记录可能的右节点
        
        * 98  验证二插搜索树：
                        
        104. 二叉树最大深度：可以用递归。 
        
        *108. 有序数组转化二插搜索树： 类似二分法， 借助left，right 取中点mid， 进行递归。
        
        116. 填充右侧节点： 有空间O(1) 做法， 直接 Node->left->next= node->right
                                          记录最左节点，为换行做准备。
                                          还要判断是否 node->next :  行内换节点。
        
        
        *127. 单词接龙： bfs思想    unordered_set, 对每个字母进行a到z替换    再进行回溯。
                                                 *每次回溯要记得在set中erase掉现在的string
        
        *128.  最长连续序列:  unordered_set,  先找左边界， 再一个一个往右侧查找。
        
        *131. 分割回文串： 经典回溯法
        
        *130. 围绕的区域：   思路：从四个边开始将'O' dfs 都变成'#'; 最后再将‘#’变回来
        
        *134. 加油站： 判断能否一周： gas总值要大于等于cost； 所以要用两个变量，一个记录总gas-cost；
                                    一个记录当前gas-cost  如果当前为负数，要重新改变起始点。
        
        *138. 复制随机指针链表： 利用hashmap，  hash[head]=new Node(head->val);
        
        
        *139. 单词拆分： 动态规划思想， dp(n+1);    i从1开始，j 从i-1往后找dp==1的值，代表之前的子串都在
                                                  词典中。
                                       for(int i=1;i<=n;++i){
                                           for(int j=i-1;j>=0;--j{
                                                if(dp[j] &&hash.count(s.substr(j,i-i)){
                                                    dp[i]=1;
                                                    break;
                                                }
                                           }
                                       }
         /*140. 单词拆分2：                              
                                       
        147. 链表插排：   从head->next开始，对pre进行比较，如果小于pre ，从头递归找第一个大于cur
                          的节点。
        *148 排序链表
      
           两两交换链表
           
           连续k个交换链表

          /*149. 直线最多点：
          
          *152. 乘积最大数组： 记录 ans，min和max  动态规划，每次更新min和max, ans=max(ans,max)
          
          *162. 寻找峰值： 二分查找模板
          
          /*166. 分数化小数：
          
          172. 阶乘后零的个数： 计算因子5的个数，  n/=5; ans+=n;
          
          
          *189. 旋转数组：  三次反转， 先反转左边， 再翻右边， 最后整体反转
          
          *190. 颠倒二进制： ans+=(n&1)<<p; p--; n>>1;
          
          202. 快乐数： 快慢指针思想， 
            
          *204. 质数计算：   动态规划：  预设所有为质数，迭代发现质数时，向上继续二次迭代，
                                    j从2*i开始，每次增加i，将j改为非质数。

          
          **207. 课程表。 拓扑排序   先逆转记录edge，同时也记录出度d；  再用queue辅助
                                                   记录变量visit 最后比较visit和nums

          /**208. Trie前缀树：
          
          /**212. 单词搜索II：利用前缀树。
          
          *239. 滑动窗口最大值：deque

          242. 字母异位词：  hashmap,   优化版可用 26数组代替hashmap；
                                       **注意类内数组需要初始化={0}, 否则会随机初始化。

          268. 缺失数字：  可以用数学方法， 1到n的和减去 数组总和。
          
          *279. 完全平方数：双层循环，  第二层要判断倍数
                          
                          for(int i=1;i<=n;++i){
                                for (int j=1;j*j<=i;++j)
                                
           *283. 移动0：       双指针，用一个单独指针指向不等于0的位置；循环们找不等于0的元素。
           
           
           
           *287. 寻找重复数：  二分查找，利用前缀和判断
                              **快慢指针思想
           
            /*295 数据流中位数
            
            *300. 最长上升子序列： 动态规划。 双层迭代  if( nums[i]>nums[j])    dp[i]=max(dp[i],dp[j]+1);
          
            /*315. 右侧小于当全元素个数
            
            
            *326. 3的幂次方：  换底公式：log10(n)/log10(3);
            
            **328. 奇偶链表：
                          链表迭代，每次记录当前节点和下一个节点， 再分别更新next；
            
          
