1. 数学公式： <math.h>      fabs    sqrt    ceil   floor   

2. 保留小数点：
  <iomanip>
      cout<<setiosflags(ios::fixed)<<setprecision(2)<<
      
  <stdio.h>  
  printf("%.2f\n", sum);
      
3. 多组输入：
    while(cin>>   )
    
4. 







剑指offer

11. 旋转数组 ：  二分法 （模版）    

int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
        }
    return -1;
}



int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {  //这里很重要
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}



int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;
    
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return right - 1; // 注意
}



   26. 树的子结构  双递归。
    递归思想，如果根值不同一定不是子结构， 再查左节点和右节点。

}

29. 顺时针打印

30. 包含min 的栈    辅助栈
        当小于top时入栈，当等于stack时出栈。
        
        
 31. 压栈 出栈     辅助栈  根据push找pop栈位置   当找到相同的值，pop右移辅助stackpop(). 
 
 34 后续遍历？    单调栈
 
 35 链表深复制
             利用 hashmap
             
 *36. 二叉 双向链表    递归    node* & head , node*& pre
 
 40   top k   用桶排序


13. 机器人运动范围：写一个辅助函数，获取位的和

26. 是否子树：辅助函数来判断当前节点。
              如果节点值相等，进入辅助函数判断；
              如果不相等，在主函数中继续判断左节点和右节点。
              

29. 顺时针打印矩阵：
              
33. 二叉搜索树 后序遍历：  单调栈思想，每次循环都会比较一个最大值，大于最大值时 返回false。
单调递增栈，当遇到小于top时，更新最大值。

34. 二叉树路径和

38. 字符串全排列： 可以通过set去重， 也可以设立flag 判断前面的字符是否有重复。

*41 缺失的第一个正数：将负数先n+1 按值取负数，在遍历一次，第一个整数就是缺失的值。

*42 接雨水：    单调栈   先找底 pop， 再找左边界 不pop。


43 1出现的次数：迭代，while（n/i）  i*=10；
                每次计算high：高位值，cur：本位值；low：低位值
                ans+=high*i;  
                ans+=high*i+low+1;
                ans+=high*i+i;
                
44 数字序列某一位的数字：



46 数字->字符串   dp[i]=dp[i-1]+dp[i-2]
    LeetCode91：还要考虑‘0’的情况，当s[i]=='0'时，判断s[i-1]=='1' or '2' : dp[i]=dp[i-2]

49 丑数， 动态规划    p2, p3, p5     dp[i]=min(dp[p2]*2,dp[p3]*3,dp[p5]*5);


51  数组逆序对：
              可以用归并排序，  每次把left放进去时，都会计算一次right的偏移量right-m-1，
              把这个值加到结果。
              
53. 经典二分查找    l=i;   r=j;                                                                 



56. 数组中出现 两个数没出现2次：  找到两者异或值， 再找 最近的位值为一。

57. 和为s 连续正数序列：
      i=1, j=2;    sum=(i+j)*(j-i+1)/2;       













leetcode：
      
      22. 括号生成： 回溯法，open < n，close <open  分别对左右括号进行回溯。
      
      23. 合并升序链表
          分治归并，类似归并排序。
       
       26. 原地删除重复项： 双指针
       
       *28. strstr（）  字符串匹配， kmp算法
          
       33. 旋转排序数组:
            
            二分查找， nums[m]==target;
                      nums[m]<=nums[nums.size()-1];  target>nums[m] && target<=nums[nums.size()-1]
                      nums[m]>nums[nums.size()-1];   target>=nums[0] && target<nums[m]
       
       
      36. 数独：   利用哈希表
                    row[9][9]    col[9][9]   box[9][9]
                    row[i][n]=1;     col[j][n]=1;   box[(i/3)*3+j/3][n]=1;
                    
       *37. 解数独： 回溯法， 记录‘。’数组。    记录。的数量， 当。被填满后 回溯结束。
       
       38. 外观数列： 动态规划， 再用判断连续字符串。
       str[j]!=str[j-1] -> s+=j-i+'0'; s+=str[j-1];
       
       54. 螺旋矩阵：(剑指offer29题类似) 辅助visited矩阵， 遍历i,j...
       
       55. 跳跃游戏： 贪心算法 记录最远坐标r。当坐标小于等于r时，可以更新r；否则错误。
       
       56. 合并区间： 排序， 再比较每个区域的右边界
       
       *73. 矩阵置零：   思想：用第一行 第一列是否为0表示全数组。 但要注意，第一行和第一列matrix[0][0]
                        1. 标记第一行和第一列。 注意： 另外用一个flag存贮第一列的状态（是否有0）；
                        2. *从右下往上遍历，如果 matrix[i][0]或 matrix[0][j]==0 ,则赋值0；
                        3. 每次遍历除1外所有列后，才会判断flag：matrix[i][0]
                        
        74 搜索二维矩阵：  取左下角进行比较                
                        
          
      76. 最小覆盖子串：     滑动窗口,两个hashmap记录窗口和need。 再用变量valid记录相等的元素数量，
                          判断valid是否满足need。
      
        
        *88. 原地合并两数组： 从后往前， 双指针。
        
        *91 数字转字符串
        
        
        *94. 二叉树遍历  递归版   借助stack
        
            *后序遍历: 额外需要 pre节点记录可能的右节点
        
        * 98  验证二插搜索树：
                        
        104. 二叉树最大深度：可以用递归。 
        
        *108. 有序数组转化二插搜索树： 类似二分法， 借助left，right 取中点mid， 进行递归。
        
        147. 链表插排：   从head->next开始，对pre进行比较，如果小于pre ，从头递归找第一个大于cur
                          的节点。
        *148 排序链表
      
           两两交换链表
           
           连续k个交换链表

          
          
          
          
          
          
          
          
          












